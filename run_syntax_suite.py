#!/bin/python3

import os
import re
import csv
from pathlib import Path
from subprocess import Popen, PIPE, TimeoutExpired
from typing import List
from fpga_timing_benchmarks.benchmarks.basic import BasicBenchmark
from fpga_timing_benchmarks.benchmarks.benchmark import NetlistType


class FPGAArch:
    name: str
    route_chan_w: int
    arch_xml_file: Path
    arch_rr_graph: Path
    device: str
    liberty_files: List[Path]


class Z1010FPGA(FPGAArch):
    def __init__(self, z1010_cad_dir: Path):
        self.name = "z1010"
        self.route_chan_w = 100
        self.arch_xml_file = os.path.join(z1010_cad_dir, "z1010.xml")
        self.arch_rr_graph = os.path.join(z1010_cad_dir, "z1010_rr_graph.xml")
        self.device = "z1010"

        self.liberty_files = []
        for file in os.listdir(z1010_cad_dir):
            if file.endswith(".lib"):
                self.liberty_files.append(os.path.join(z1010_cad_dir, file))

    def verify(self) -> bool:
        assert os.path.exists(self.arch_xml_file)
        assert os.path.exists(self.arch_rr_graph)
        assert all(os.path.exists(f) for f in self.liberty_files)
        return True


def synthesize_circuit(verilog_file: Path,
                       top_level_module: str,
                       output_netlist_file: Path,
                       output_blif_file: Path,
                       run_dir: Path):
    """
    Synthesizes the circuit given by the provided verilog file using Yosys +
    the Wildebeest plugin. This is necessary in order to create a netlist that
    can be used by VPR and OpenSTA.

    Args:
        verilog_file (Path): The path to the verilog file to synthesize.
        top_level_module (str): The name of the top-level module for the ciruit.
        output_netlist_file (Path): The Path for the output Verilog file.
        output_blif_file (Path): The Path for the output blif file.
        run_dir (Path): The directory to run Yosys in.
    """
    assert os.path.exists(verilog_file)
    assert not os.path.exists(output_netlist_file)
    assert not os.path.exists(output_blif_file)
    assert os.path.exists(run_dir)

    # Change the directory to the given run directory.
    os.chdir(run_dir)

    # Create the commands to run in Yosys.
    #   Use the wildebeest plugin.
    yosys_commands = "plugin -i wildebeest;"
    #   Read the provided verilog file.
    yosys_commands += f" read_verilog {verilog_file};"
    #   Set the top-level module.
    yosys_commands += f" hierarchy -check -top {top_level_module};"
    #   Run Wildebeest for the z1010 architecture.
    yosys_commands += " synth_fpga -partname z1010;"
    #   Write the verilog netlist file.
    #   NOTE: The -noexpr option is used to turn expressions into cells for OpenSTA
    #         to parse. OpenSTA cannot handle verilog expressions.
    #   NOTE: The -defparam option is required for the luts generated by noexpr
    #         since OpenSTA requires that syntax.
    yosys_commands += f" write_verilog -noexpr -defparam {output_netlist_file};"
    #   Write the blif netlist file.
    yosys_commands += f" write_blif {output_blif_file};"

    # Create a process that will run Yosys (whatever Yosys is in the PATH), with
    # the commands.
    process_args = ["yosys",
                    "--commands",
                    yosys_commands]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("wildebeest.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("wildebeest_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()


def verify_sdc_with_opensta(sdc_file: Path,
                            netlist_file: Path,
                            liberty_files: List[Path],
                            top_level_module: str,
                            run_dir: Path) -> bool:
    """
    Use OpenSTA to verify that the given SDC file is valid. This passes the
    provided Verilog netlist file and SDC file into OpenSTA and checks for
    errors in the parsing.

    Args:
        sdc_file (Path): The Path to the SDC file to verify.
        netlist_file (Path): The Path to the Verilog SDC file associated with the SDC file.
        liberty_files (List[Path]): List of liberty files for the FPGA architecture.
        top_level_module (str): The top-level module for the circuit.
        run_dir (Path): Path to the directory to run OpenSTA in.

    Returns:
        bool: If the SDC file is valid or not.
    """
    assert os.path.exists(sdc_file)
    assert os.path.exists(netlist_file)
    assert all(os.path.exists(f) for f in liberty_files)
    assert os.path.exists(run_dir)

    # Change the current directory to the given run directory.
    os.chdir(run_dir)

    # Create the path to a TCL file which will be used to verify the SDC file.
    tcl_file = os.path.join(run_dir, "verify_sdc.tcl")

    # Create a tcl file to verify an sdc file.
    with open(tcl_file, "w") as f:
        # Read the verilog file.
        f.write(f"read_verilog {netlist_file}\n")
        # Read the liberty files.
        for liberty_file in liberty_files:
            f.write(f"read_liberty {liberty_file}\n")
        # Link the top-level module.
        f.write(f"link_design {top_level_module}\n")
        # Read the SDC file. This command will throw an error if there is
        # something wrong with the SDC file.
        f.write(f"read_sdc {sdc_file}\n")

    # Create a process which will run the TCL file through OpenSTA (whatever
    # is in the PATH).
    process_args = ["sta",
                    "-exit",
                    "-no_splash",
                    tcl_file]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("sta_verify_sdc.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("sta_verify_sdc_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()

    # Check if stdout or stderr contain any "Error"s.
    if str(stdout).find("Error") != -1:
        return False
    if str(stderr).find("Error") != -1:
        return False
    return True


def test_vpr_sdc_syntax(sdc_file: Path,
                        blif_file: Path,
                        fpga_arch: FPGAArch,
                        run_dir: Path) -> bool:
    """
    Test that the given SDC file can be parsed by VPR. This will run VPR up to
    the packing step and check that it succeeds.

    Args:
        sdc_file (Path): The Path to the SDC file.
        blif_file (Path): The Path to the blif file.
        fpga_arch (FPGAArch): The FPGA architecture to run VPR on.
        run_dir (Path): The directory to run VPR in.

    Returns:
        bool: If VPR successfully parsed the SDC file or not.
    """
    assert fpga_arch.verify()
    assert os.path.exists(sdc_file)
    assert os.path.exists(blif_file)
    assert os.path.exists(run_dir)

    # Change the current directory to the given run directory.
    os.chdir(run_dir)

    # Create a process that will run VPR with the given SDC file. This does not
    # need to run VPR to completion, so we only run up to the end of packing.
    process_args = ["vpr",
                    fpga_arch.arch_xml_file,
                    blif_file,
                    "--device", fpga_arch.device,
                    "--sdc_file", sdc_file,
                    "--read_rr_graph", fpga_arch.arch_rr_graph,
                    "--route_chan_width", str(fpga_arch.route_chan_w),
                    "--pack"]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("vpr_test_sdc_syntax.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("vpr_test_sdc_syntax_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()

    # Check for a syntax error in VTR's output.
    if stderr.decode().find("syntax error") != -1:
        return False

    # Check if VPR failed to run.
    if stdout.decode().find("VPR succeeded") == -1:
        return False

    return True


def create_run_dir(base_dir: Path) -> Path:
    """
    Given a base run directory, create a unique run folder within it. If the
    folder is empty, this will create a directory named run001. The next run
    directory would then be called run002, and so on.

    Args:
        base_dir (Path): The Path to the base run directory.

    Returns:
        Path: The Path to the newly created run directory.
    """
    assert os.path.exists(base_dir)

    # Find all of the existing run directories.
    run_folder_pattern = re.compile(r"^run(\d{3})$")
    existing_run_numbers = []
    for item in os.listdir(base_dir):
        match = run_folder_pattern.match(item)
        if match and os.path.isdir(os.path.join(base_dir, item)):
            existing_run_numbers.append(int(match.group(1)))

    # Pick the next run number based on that.
    if existing_run_numbers:
        next_run_number = max(existing_run_numbers) + 1
    else:
        next_run_number = 1

    # Create the new directory.
    new_dir_name = f"run{next_run_number:03d}"
    new_dir_path = os.path.join(base_dir, new_dir_name)
    os.mkdir(new_dir_path)

    return new_dir_path


if __name__ == "__main__":
    script_dir_path = os.path.dirname(os.path.realpath(__file__))

    # Create a temporary run directory for the files generated by this flow.
    base_run_dir_path = os.path.join(script_dir_path, "runs")
    if not os.path.exists(base_run_dir_path):
        os.mkdir(base_run_dir_path)
    run_dir_path = create_run_dir(base_run_dir_path)

    # Initialize the benchmark to test.
    basic_benchmark = BasicBenchmark()

    # Create a run directory for this benchmark.
    basic_run_dir_path = os.path.join(run_dir_path, basic_benchmark.name)
    os.mkdir(basic_run_dir_path)

    # Create the z1010 FPGA.
    z1010_cad_dir = os.path.join(script_dir_path, "z1010", "cad")
    z1010_fpga = Z1010FPGA(z1010_cad_dir)

    # Collect result data for the designs.
    result_data = [[
        "Test Suite",
        "Test Name",
        "SDC Verified with OpenSTA?",
        "SDC Parsed by VPR Without Error?",
    ]]

    # Test the given design.
    for design in basic_benchmark.designs:
        assert design.netlist_type is NetlistType.VERILOG

        print(f"Testing design {design.test_name}...")

        design_run_dir_path = os.path.join(basic_run_dir_path, design.test_name)
        os.mkdir(design_run_dir_path)

        output_netlist_file = os.path.join(design_run_dir_path, "synth_output.vg")
        output_blif_file = os.path.join(design_run_dir_path, "synth_output.blif")
        synthesize_circuit(verilog_file=design.netlist_file,
                           top_level_module=design.top_level_module,
                           output_netlist_file=output_netlist_file,
                           output_blif_file=output_blif_file,
                           run_dir=design_run_dir_path)

        sdc_is_valid = verify_sdc_with_opensta(sdc_file=design.sdc_file,
                                               netlist_file=output_netlist_file,
                                               liberty_files=z1010_fpga.liberty_files,
                                               top_level_module=design.top_level_module,
                                               run_dir=design_run_dir_path)

        if not sdc_is_valid:
            print("\tSDC is invalid!")
        else:
            print("\tSDC is valid!")

        vpr_succeeded = test_vpr_sdc_syntax(sdc_file=design.sdc_file,
                                            blif_file=output_blif_file,
                                            fpga_arch=z1010_fpga,
                                            run_dir=design_run_dir_path)

        if vpr_succeeded:
            print("\tVPR successfully parsed the SDC file.")
        else:
            print("\tVPR failed to parse the SDC file.")

        result_data.append([
            basic_benchmark.name,
            design.test_name,
            str(sdc_is_valid),
            str(vpr_succeeded),
        ])

    # Write the results to a CSV file.
    result_csv_file = os.path.join(run_dir_path, "results.csv")
    with open(result_csv_file, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(result_data)
    print(f"Results have been written to {result_csv_file}")
