#!/bin/python3

import os
import re
import csv
from pathlib import Path
from subprocess import Popen, PIPE, TimeoutExpired
from typing import List
from fpga_timing_benchmarks.benchmarks.basic import BasicBenchmark
from fpga_timing_benchmarks.benchmarks.benchmark import NetlistType


class FPGAArch:
    name: str
    route_chan_w: int
    arch_xml_file: Path
    arch_rr_graph: Path
    device: str
    liberty_files: List[Path]


class Z1010FPGA(FPGAArch):
    def __init__(self, z1010_cad_dir: Path):
        self.name = "z1010"
        self.route_chan_w = 100
        self.arch_xml_file = os.path.join(z1010_cad_dir, "z1010.xml")
        self.arch_rr_graph = os.path.join(z1010_cad_dir, "z1010_rr_graph.xml")
        self.device = "z1010"

        self.liberty_files = []
        for file in os.listdir(z1010_cad_dir):
            if file.endswith(".lib"):
                self.liberty_files.append(os.path.join(z1010_cad_dir, file))

    def verify(self) -> bool:
        assert os.path.exists(self.arch_xml_file)
        assert os.path.exists(self.arch_rr_graph)
        assert all(os.path.exists(f) for f in self.liberty_files)
        return True


def synthesize_circuit(verilog_file: Path,
                       top_level_module: str,
                       output_netlist_file: Path,
                       output_blif_file: Path,
                       run_dir: Path):
    """
    Synthesizes the circuit given by the provided verilog file using Yosys +
    the Wildebeest plugin. This is necessary in order to create a netlist that
    can be used by VPR and OpenSTA.

    Args:
        verilog_file (Path): The path to the verilog file to synthesize.
        top_level_module (str): The name of the top-level module for the circuit.
        output_netlist_file (Path): The Path for the output Verilog file.
        output_blif_file (Path): The Path for the output blif file.
        run_dir (Path): The directory to run Yosys in.
    """
    assert os.path.exists(verilog_file)
    assert not os.path.exists(output_netlist_file)
    assert not os.path.exists(output_blif_file)
    assert os.path.exists(run_dir)

    # Change the directory to the given run directory.
    os.chdir(run_dir)

    # Create the commands to run in Yosys.
    #   Use the wildebeest plugin.
    yosys_commands = "plugin -i wildebeest;"
    #   Read the provided verilog file.
    yosys_commands += f" read_verilog {verilog_file};"
    #   Set the top-level module.
    yosys_commands += f" hierarchy -check -top {top_level_module};"
    #   Run Wildebeest for the z1010 architecture.
    yosys_commands += " synth_fpga -partname z1010;"
    #   Write the verilog netlist file.
    #   NOTE: The -noexpr option is used to turn expressions into cells for OpenSTA
    #         to parse. OpenSTA cannot handle verilog expressions.
    #   NOTE: The -defparam option is required for the luts generated by noexpr
    #         since OpenSTA requires that syntax.
    yosys_commands += f" write_verilog -noexpr -defparam {output_netlist_file};"
    #   Write the blif netlist file.
    yosys_commands += f" write_blif {output_blif_file};"

    # Create a process that will run Yosys (whatever Yosys is in the PATH), with
    # the commands.
    process_args = ["yosys",
                    "--commands",
                    yosys_commands]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("wildebeest.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("wildebeest_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()


def verify_sdc_with_opensta(sdc_file: Path,
                            netlist_file: Path,
                            liberty_files: List[Path],
                            top_level_module: str,
                            run_dir: Path) -> bool:
    """
    Use OpenSTA to verify that the given SDC file is valid. This passes the
    provided Verilog netlist file and SDC file into OpenSTA and checks for
    errors in the parsing.

    Args:
        sdc_file (Path): The Path to the SDC file to verify.
        netlist_file (Path): The Path to the Verilog SDC file associated with the SDC file.
        liberty_files (List[Path]): List of liberty files for the FPGA architecture.
        top_level_module (str): The top-level module for the circuit.
        run_dir (Path): Path to the directory to run OpenSTA in.

    Returns:
        bool: If the SDC file is valid or not.
    """
    assert os.path.exists(sdc_file)
    assert os.path.exists(netlist_file)
    assert all(os.path.exists(f) for f in liberty_files)
    assert os.path.exists(run_dir)

    # Change the current directory to the given run directory.
    os.chdir(run_dir)

    # Create the path to a TCL file which will be used to verify the SDC file.
    tcl_file = os.path.join(run_dir, "verify_sdc.tcl")

    # Create a tcl file to verify an sdc file.
    with open(tcl_file, "w") as f:
        # Read the verilog file.
        f.write(f"read_verilog {netlist_file}\n")
        # Read the liberty files.
        for liberty_file in liberty_files:
            f.write(f"read_liberty {liberty_file}\n")
        # Link the top-level module.
        f.write(f"link_design {top_level_module}\n")
        # Read the SDC file. This command will throw an error if there is
        # something wrong with the SDC file.
        f.write(f"read_sdc {sdc_file}\n")

    # Create a process which will run the TCL file through OpenSTA (whatever
    # is in the PATH).
    process_args = ["sta",
                    "-exit",
                    "-no_splash",
                    tcl_file]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("sta_verify_sdc.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("sta_verify_sdc_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()

    # Check if stdout or stderr contain any "Error"s.
    if str(stdout).find("Error") != -1:
        return False
    if str(stderr).find("Error") != -1:
        return False
    return True


def test_vpr_sdc_syntax(sdc_file: Path,
                        blif_file: Path,
                        fpga_arch: FPGAArch,
                        run_dir: Path) -> bool:
    """
    Test that the given SDC file can be parsed by VPR. This will run VPR up to
    the packing step and check that it succeeds.

    Args:
        sdc_file (Path): The Path to the SDC file.
        blif_file (Path): The Path to the blif file.
        fpga_arch (FPGAArch): The FPGA architecture to run VPR on.
        run_dir (Path): The directory to run VPR in.

    Returns:
        bool: If VPR successfully parsed the SDC file or not.
    """
    assert fpga_arch.verify()
    assert os.path.exists(sdc_file)
    assert os.path.exists(blif_file)
    assert os.path.exists(run_dir)

    # Change the current directory to the given run directory.
    os.chdir(run_dir)

    # Create a process that will run VPR with the given SDC file. This does not
    # need to run VPR to completion, so we only run up to the end of packing.
    process_args = ["vpr",
                    fpga_arch.arch_xml_file,
                    blif_file,
                    "--device", fpga_arch.device,
                    "--sdc_file", sdc_file,
                    "--read_rr_graph", fpga_arch.arch_rr_graph,
                    "--route_chan_width", str(fpga_arch.route_chan_w),
                    "--pack"]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("vpr_test_sdc_syntax.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("vpr_test_sdc_syntax_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()

    # Check for a syntax error in VTR's output.
    if stderr.decode().find("syntax error") != -1:
        return False

    # Check if VPR failed to run.
    if stdout.decode().find("VPR succeeded") == -1:
        return False

    return True


def place_and_route_with_vpr(sdc_file: Path,
                             blif_file: Path,
                             fpga_arch: FPGAArch,
                             run_dir: Path) -> bool:
    """
    Run place and route on the given circuit and SDC constraints using VPR.
    This will run VPR and generate the post-implementation netlist and timing
    information that OpenSTA can use to verify the timing of the circuit.

    Args:
        sdc_file (Path): The Path to the SDC file.
        blif_file (Path): The Path to the blif file.
        fpga_arch (FPGAArch): The FPGA architecture to run VPR on.
        run_dir (Path): The directory to run VPR in.

    Returns:
        bool: If VPR successfully performed place and route or not.
    """
    assert fpga_arch.verify()
    assert os.path.exists(sdc_file)
    assert os.path.exists(blif_file)
    assert os.path.exists(run_dir)

    # Change the current directory to the given run directory.
    os.chdir(run_dir)

    # Create a process that will run VPR with the given SDC file. This does not
    # need to run VPR to completion, so we only run up to the end of packing.
    process_args = ["vpr",
                    fpga_arch.arch_xml_file,
                    blif_file,
                    "--device", fpga_arch.device,
                    "--sdc_file", sdc_file,
                    "--read_rr_graph", fpga_arch.arch_rr_graph,
                    "--route_chan_width", str(fpga_arch.route_chan_w),
                    "--router_lookahead", "classic",
                    "--gen_post_synthesis_netlist", "on",
                    "--gen_post_implementation_sdc", "on",
                    "--post_synth_netlist_unconn_inputs", "gnd",
                    "--post_synth_netlist_module_parameters", "off",
                    "--pack",
                    "--place",
                    "--route"]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("vpr_place_and_route.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("vpr_place_and_route_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()

    # Check if VPR failed to run.
    if stdout.decode().find("VPR succeeded") == -1:
        return False

    return True


def get_vpr_timing_results(run_dir: Path) -> (float, float):
    """
    Get the timing results from the last place and route performed using VPR.

    Args:
        run_dir (Path): Path to the directory that ran VPR.

    Returns:
        (float, float): wns, tns
    """
    vpr_wns = None
    vpr_tns = None
    vpr_run_stdout = os.path.join(run_dir, "vpr_place_and_route.out")
    assert os.path.exists(vpr_run_stdout)
    with open(vpr_run_stdout, "r") as f:
        for line in f.readlines():
            wns_match = re.search(r"^Final setup Worst Negative Slack \(sWNS\): (\S+) ns",
                                  line)
            tns_match = re.search(r"^Final setup Total Negative Slack \(sTNS\): (\S+) ns",
                                  line)
            if wns_match:
                assert vpr_wns is None
                vpr_wns = float(wns_match.group(1))
            if tns_match:
                assert vpr_tns is None
                vpr_tns = float(tns_match.group(1))

    return (vpr_wns, vpr_tns)


def verify_vpr_timing_analysis_with_opensta(liberty_files: List[Path],
                                            top_level_module: str,
                                            run_dir: Path) -> bool:
    """
    Verify VPR's timing analysis by doing post-implementation timing analysis
    with OpenSTA and check that it gets a similar answer to VPR.

    Args:
        liberty_files (List[Path]): List of liberty files for the FPGA architecture.
        top_level_module (str): The top-level module for the circuit.
        run_dir (Path): Path to the directory to run OpenSTA in.

    Returns:
        bool: If the timings between VPR and OpenSTA are similar or not.
    """
    assert all(os.path.exists(f) for f in liberty_files)
    assert os.path.exists(run_dir)

    # Change the current directory to the given run directory.
    os.chdir(run_dir)

    # Get the post-implementation netlist and timing files from the last run
    # of VPR.
    # NOTE: This is a bit of a hack since we cannot control the names of these
    #       files.
    post_impl_netlist = os.path.join(run_dir, f"{top_level_module}_post_synthesis.v")
    post_impl_sdc = os.path.join(run_dir, f"{top_level_module}_post_synthesis.sdc")
    post_impl_sdf = os.path.join(run_dir, f"{top_level_module}_post_synthesis.sdf")

    # Create the path to a TCL file which will be used to verify the SDC file.
    tcl_file = os.path.join(run_dir, "verify_vpr.tcl")

    # Create a tcl file to perform post-implementation timing analysis.
    with open(tcl_file, "w") as f:
        # Read the verilog file.
        f.write(f"read_verilog {post_impl_netlist}\n")
        # Read the liberty files.
        for liberty_file in liberty_files:
            f.write(f"read_liberty {liberty_file}\n")
        # Link the top-level module.
        f.write(f"link_design {top_level_module}\n")
        # Read the sdf file.
        f.write(f"read_sdf {post_impl_sdf}\n")
        # Read the SDC file. This command will throw an error if there is
        # something wrong with the SDC file.
        f.write(f"read_sdc {post_impl_sdc}\n")

        f.write("report_checks "
                "-group_path_count 100 "
                "-digits 3 "
                "-path_delay max "
                "> open_sta_report_timing.setup.rpt\n")
        f.write("report_checks "
                "-group_path_count 100 "
                "-digits 3 "
                "-path_delay min "
                "> open_sta_report_timing.hold.rpt\n")
        f.write("report_wns\n")
        f.write("report_tns\n")

    # Create a process which will run the TCL file through OpenSTA (whatever
    # is in the PATH).
    process_args = ["sta",
                    "-exit",
                    "-no_splash",
                    tcl_file]
    process = Popen(process_args,
                    stdout=PIPE,
                    stderr=PIPE)

    # Run the process.
    try:
        stdout, stderr = process.communicate(timeout=None)
    except TimeoutExpired:
        process.kill()
        stdout, stderr = process.communicate()

    # Save stdout and stderr to files for debugging.
    with open("sta_verify_vpr.out", "w") as f:
        f.write(stdout.decode())
        f.close()
    with open("sta_verify_vpr_err.out", "w") as f:
        f.write(stderr.decode())
        f.close()

    # Check if stdout or stderr contain any "Error"s.
    if str(stdout).find("Error") != -1:
        return False
    if str(stderr).find("Error") != -1:
        return False

    # Parse the wns and tns from OpenSTA
    opensta_wns = None
    opensta_tns = None
    for line in stdout.splitlines():
        wns_match = re.search(r"^wns max (\S+)",
                              line.decode())
        tns_match = re.search(r"^tns max (\S+)",
                              line.decode())
        if wns_match:
            assert opensta_wns is None
            opensta_wns = float(wns_match.group(1))
        if tns_match:
            assert opensta_tns is None
            opensta_tns = float(tns_match.group(1))

    if opensta_wns is None or opensta_tns is None:
        return False

    # Parse the wns and tns from VPR
    (vpr_wns, vpr_tns) = get_vpr_timing_results(run_dir)
    if vpr_wns is None or vpr_tns is None:
        return False

    # Check that the two tools mostly agree on WNS and TNS
    if abs(opensta_wns - vpr_wns) >= 0.01 * max(abs(opensta_wns), abs(vpr_wns)) + 0.006:
        return False
    if abs(opensta_tns - vpr_tns) >= 0.01 * max(abs(opensta_tns), abs(vpr_tns)) + 0.006:
        return False

    return True


def does_vpr_meet_timing(run_dir: Path) -> bool:
    """
    Checks if vpr met timing with this benchmark when it ran place and route.

    Args:
        run_dir (Path): Path to the directory that ran vpr.

    Returns:
        bool: True if VPR meets timing, false otherwise.
    """
    (vpr_wns, vpr_tns) = get_vpr_timing_results(run_dir)
    if vpr_wns is None:
        return False

    if abs(vpr_wns) > 0.0:
        return False

    return True


def create_run_dir(base_dir: Path) -> Path:
    """
    Given a base run directory, create a unique run folder within it. If the
    folder is empty, this will create a directory named run001. The next run
    directory would then be called run002, and so on.

    Args:
        base_dir (Path): The Path to the base run directory.

    Returns:
        Path: The Path to the newly created run directory.
    """
    assert os.path.exists(base_dir)

    # Find all of the existing run directories.
    run_folder_pattern = re.compile(r"^run(\d{3})$")
    existing_run_numbers = []
    for item in os.listdir(base_dir):
        match = run_folder_pattern.match(item)
        if match and os.path.isdir(os.path.join(base_dir, item)):
            existing_run_numbers.append(int(match.group(1)))

    # Pick the next run number based on that.
    if existing_run_numbers:
        next_run_number = max(existing_run_numbers) + 1
    else:
        next_run_number = 1

    # Create the new directory.
    new_dir_name = f"run{next_run_number:03d}"
    new_dir_path = os.path.join(base_dir, new_dir_name)
    os.mkdir(new_dir_path)

    return new_dir_path


if __name__ == "__main__":
    script_dir_path = os.path.dirname(os.path.realpath(__file__))

    # Create a temporary run directory for the files generated by this flow.
    base_run_dir_path = os.path.join(script_dir_path, "runs")
    if not os.path.exists(base_run_dir_path):
        os.mkdir(base_run_dir_path)
    run_dir_path = create_run_dir(base_run_dir_path)

    # Initialize the benchmark to test.
    basic_benchmark = BasicBenchmark()

    # Create a run directory for this benchmark.
    basic_run_dir_path = os.path.join(run_dir_path, basic_benchmark.name)
    os.mkdir(basic_run_dir_path)

    # Create the z1010 FPGA.
    z1010_cad_dir = os.path.join(script_dir_path, "z1010", "cad")
    z1010_fpga = Z1010FPGA(z1010_cad_dir)

    # Collect result data for the designs.
    result_data = [[
        "Test Suite",
        "Test Name",
        "SDC Verified with OpenSTA?",
        "SDC Parsed by VPR Without Error?",
        "Place and Route Succeeded?",
        "VPR and OpenSTA Have Similar Timings?",
        "Did VPR Meet Timing?",
    ]]

    # Test the given design.
    for design in basic_benchmark.designs:
        assert design.netlist_type is NetlistType.VERILOG

        print(f"Testing design {design.test_name}...")

        design_run_dir_path = os.path.join(basic_run_dir_path, design.test_name)
        os.mkdir(design_run_dir_path)

        output_netlist_file = os.path.join(design_run_dir_path, "synth_output.vg")
        output_blif_file = os.path.join(design_run_dir_path, "synth_output.blif")
        synthesize_circuit(verilog_file=design.netlist_file,
                           top_level_module=design.top_level_module,
                           output_netlist_file=output_netlist_file,
                           output_blif_file=output_blif_file,
                           run_dir=design_run_dir_path)

        sdc_is_valid = verify_sdc_with_opensta(sdc_file=design.sdc_file,
                                               netlist_file=output_netlist_file,
                                               liberty_files=z1010_fpga.liberty_files,
                                               top_level_module=design.top_level_module,
                                               run_dir=design_run_dir_path)

        if not sdc_is_valid:
            print("\tSDC is invalid!")
        else:
            print("\tSDC is valid!")

        vpr_succeeded = test_vpr_sdc_syntax(sdc_file=design.sdc_file,
                                            blif_file=output_blif_file,
                                            fpga_arch=z1010_fpga,
                                            run_dir=design_run_dir_path)

        if vpr_succeeded:
            print("\tVPR successfully parsed the SDC file.")
        else:
            print("\tVPR failed to parse the SDC file.")

        place_and_route_succeeded = "NULL"
        vpr_timing_valid = "NULL"
        vpr_meets_timing = "NULL"
        if vpr_succeeded:
            place_and_route_succeeded = place_and_route_with_vpr(sdc_file=design.sdc_file,
                                                                 blif_file=output_blif_file,
                                                                 fpga_arch=z1010_fpga,
                                                                 run_dir=design_run_dir_path)

            if place_and_route_succeeded:
                print("\t\tPlace and route succeeded.")
                vpr_timing_valid = verify_vpr_timing_analysis_with_opensta(
                        liberty_files=z1010_fpga.liberty_files,
                        top_level_module=design.top_level_module,
                        run_dir=design_run_dir_path)
                if vpr_timing_valid:
                    print("\t\t\tPlace and route timing is valid")
                    vpr_meets_timing = does_vpr_meet_timing(run_dir=design_run_dir_path)
                    if vpr_meets_timing:
                        print("\t\t\t\tPlace and Route met timing")
                    else:
                        print("\t\t\t\tPlace and Route did not meet timing!")
                else:
                    print("\t\t\tPlace and route timing found to be invalid")
            else:
                print("\t\tPlace and route failed!")

        result_data.append([
            basic_benchmark.name,
            design.test_name,
            str(sdc_is_valid),
            str(vpr_succeeded),
            str(place_and_route_succeeded),
            str(vpr_timing_valid),
            str(vpr_meets_timing),
        ])

    # Write the results to a CSV file.
    result_csv_file = os.path.join(run_dir_path, "results.csv")
    with open(result_csv_file, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(result_data)
    print(f"Results have been written to {result_csv_file}")
